@testable import NESKit
import XCTest

let snakeGame: [UInt8] = [
    0x20, 0x06, 0x06, 0x20, 0x38, 0x06, 0x20, 0x0d, 0x06, 0x20, 0x2a, 0x06, 0x60, 0xa9, 0x02,
    0x85, 0x02, 0xa9, 0x04, 0x85, 0x03, 0xa9, 0x11, 0x85, 0x10, 0xa9, 0x10, 0x85, 0x12, 0xa9,
    0x0f, 0x85, 0x14, 0xa9, 0x04, 0x85, 0x11, 0x85, 0x13, 0x85, 0x15, 0x60, 0xa5, 0xfe, 0x85,
    0x00, 0xa5, 0xfe, 0x29, 0x03, 0x18, 0x69, 0x02, 0x85, 0x01, 0x60, 0x20, 0x4d, 0x06, 0x20,
    0x8d, 0x06, 0x20, 0xc3, 0x06, 0x20, 0x19, 0x07, 0x20, 0x20, 0x07, 0x20, 0x2d, 0x07, 0x4c,
    0x38, 0x06, 0xa5, 0xff, 0xc9, 0x77, 0xf0, 0x0d, 0xc9, 0x64, 0xf0, 0x14, 0xc9, 0x73, 0xf0,
    0x1b, 0xc9, 0x61, 0xf0, 0x22, 0x60, 0xa9, 0x04, 0x24, 0x02, 0xd0, 0x26, 0xa9, 0x01, 0x85,
    0x02, 0x60, 0xa9, 0x08, 0x24, 0x02, 0xd0, 0x1b, 0xa9, 0x02, 0x85, 0x02, 0x60, 0xa9, 0x01,
    0x24, 0x02, 0xd0, 0x10, 0xa9, 0x04, 0x85, 0x02, 0x60, 0xa9, 0x02, 0x24, 0x02, 0xd0, 0x05,
    0xa9, 0x08, 0x85, 0x02, 0x60, 0x60, 0x20, 0x94, 0x06, 0x20, 0xa8, 0x06, 0x60, 0xa5, 0x00,
    0xc5, 0x10, 0xd0, 0x0d, 0xa5, 0x01, 0xc5, 0x11, 0xd0, 0x07, 0xe6, 0x03, 0xe6, 0x03, 0x20,
    0x2a, 0x06, 0x60, 0xa2, 0x02, 0xb5, 0x10, 0xc5, 0x10, 0xd0, 0x06, 0xb5, 0x11, 0xc5, 0x11,
    0xf0, 0x09, 0xe8, 0xe8, 0xe4, 0x03, 0xf0, 0x06, 0x4c, 0xaa, 0x06, 0x4c, 0x35, 0x07, 0x60,
    0xa6, 0x03, 0xca, 0x8a, 0xb5, 0x10, 0x95, 0x12, 0xca, 0x10, 0xf9, 0xa5, 0x02, 0x4a, 0xb0,
    0x09, 0x4a, 0xb0, 0x19, 0x4a, 0xb0, 0x1f, 0x4a, 0xb0, 0x2f, 0xa5, 0x10, 0x38, 0xe9, 0x20,
    0x85, 0x10, 0x90, 0x01, 0x60, 0xc6, 0x11, 0xa9, 0x01, 0xc5, 0x11, 0xf0, 0x28, 0x60, 0xe6,
    0x10, 0xa9, 0x1f, 0x24, 0x10, 0xf0, 0x1f, 0x60, 0xa5, 0x10, 0x18, 0x69, 0x20, 0x85, 0x10,
    0xb0, 0x01, 0x60, 0xe6, 0x11, 0xa9, 0x06, 0xc5, 0x11, 0xf0, 0x0c, 0x60, 0xc6, 0x10, 0xa5,
    0x10, 0x29, 0x1f, 0xc9, 0x1f, 0xf0, 0x01, 0x60, 0x4c, 0x35, 0x07, 0xa0, 0x00, 0xa5, 0xfe,
    0x91, 0x00, 0x60, 0xa6, 0x03, 0xa9, 0x00, 0x81, 0x10, 0xa2, 0x00, 0xa9, 0x01, 0x81, 0x10,
    0x60, 0xa6, 0xff, 0xea, 0xea, 0xca, 0xd0, 0xfb, 0x60,
]

let asm = """
main:
  jsr init
  jsr loop
init:
  jsr initSnake
  jsr generateApplePosition
  rts
initSnake:
  lda #2
  sta 0x02
  lda #4
  sta 0x03
  lda #0x11
  sta 0x10
  lda #0x10
  sta 0x12
  lda #0x0f
  sta 0x14
  lda #0x04
  sta 0x11
  sta 0x13
  sta 0x15
  rts
generateApplePosition:
  lda 0xfe
  sta 0x00
  lda 0xfe
  and #0x03
  clc
  adc #2
  sta 0x01
  rts
loop:
  jsr readKeys
  jsr checkCollision
  jsr updateSnake
  jsr drawApple
  jsr drawSnake
  jsr spinWheels
  jmp loop
readKeys:
  lda 0xff
  cmp #0x77
  beq upKey
  cmp #0x64
  beq rightKey
  cmp #0x73
  beq downKey
  cmp #0x61
  beq leftKey
  rts
upKey:
  lda #4
  bit 0x02
  bne illegalMove
  lda #1
  sta 0x02
  rts
rightKey:
  lda #8
  bit 0x02
  bne illegalMove
  lda #2
  sta 0x02
  rts
downKey:
  lda #1
  bit 0x02
  bne illegalMove
  lda #4
  sta 0x02
  rts
leftKey:
  lda #2
  bit 0x02
  bne illegalMove
  lda #8
  sta 0x02
  rts
illegalMove:
  rts
checkCollision:
  jsr checkAppleCollision
  jsr checkSnakeCollision
  rts
checkAppleCollision:
  lda 0x00
  cmp 0x10
  bne doneCheckingAppleCollision
  lda 0x01
  cmp 0x11
  bne doneCheckingAppleCollision
  inc 0x03
  inc 0x03
  jsr generateApplePosition
doneCheckingAppleCollision:
  rts
checkSnakeCollision:
  ldx #2
snakeCollisionLoop:
  lda #(0x10,x)
  cmp 0x10
  bne continueCollisionLoop
maybeCollided:
  lda #(0x11, x)
  cmp 0x11
  beq didCollide
continueCollisionLoop:
  inx
  inx
  cpx 0x03
  beq didntCollide
  jmp snakeCollisionLoop
didCollide:
  jmp gameOver
didntCollide:
  rts
updateSnake:
  ldx 0x03
  dex
  txa
updateloop:
  lda #(0x10, x)
  sta #(0x12, x)
  dex
  bpl updateloop
  lda 0x02
  lsr A
  bcs up
  lsr A
  bcs right
  lsr A
  bcs down
  lsr A
  bcs left
up:
  lda 0x10
  sec
  sbc #0x20
  sta 0x10
  bcc upup
  rts
upup:
  dec 0x11
  lda #0x1
  cmp 0x11
  beq collision
  rts
right:
  inc 0x10
  lda #0x1f
  bit 0x10
  beq collision
  rts
down: 
  lda 0x10
  clc
  adc #0x20
  sta 0x10
  bcs downdown
  rts
downdown:
  inc 0x11
  lda #0x6
  cmp 0x11
  beq collision
  rts
left:
  dec 0x10
  lda 0x10
  and #0x1f
  cmp #0x1f
  beq collision
  rts
collision:
  jmp gameOver
drawApple:
  ldy #0
  lda 0xfe
  sta (0x00, y)
  rts
drawSnake:
  ldx #0
  lda #1
  sta (0x10, x)
  ldx 0x03
  lda #0
  sta (0x10, x)
  rts
spinWheels:
  ldx #0
spinloop:
  nop
  nop
  dex
  bne spinloop
  rts
gameOver:
  brk
"""

final class CPUSnakeTest: XCTestCase {
    func testSnakeGame() throws {
        // var assembler = Assembler6502()
        // try assembler.lex(source: asm)
        // try assembler.parse()
        // try assembler.assemble()

        var cpu = CPU6502()

        // cpu.nodes = assembler.nodes
        // for line in asm.split(separator: "\n") {
        //     cpu.sourceLines.append(String(line))
        // }
        // print("Original:")
        // printHexDumpForBytes(bytes: snakeGame)
        // print("Assembled:")
        // printHexDumpForBytes(bytes: assembler.assembly!)

        cpu.load(program: snakeGame)

        var steps = 0

        cpu.clockSpeed = 0

        cpu.reset()
        loop: while true {
            cpu[0xFE] = 0x02 // UInt8.random(in: 1 ..< 16)
            cpu[0xFF] = 0x77

            switch try cpu.step() {
            case .ok:
                steps += 1
            case .interrupt(let interrupt):
                steps += 1
                break loop
            }
        }
    }
}
